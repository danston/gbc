// Authors: Juyong Zhang, Bailin Deng, Zishun Liu, Giuseppe Patane, Sofien Bouaziz, Kai Hormann, and Ligang Liu, https://github.com/bldeng/LBC
// Updated by: Dmitry Anisimov danston@ymail.com.
// Copyright Juyong Zhang, Bailin Deng, Zishun Liu, Giuseppe Patane, Sofien Bouaziz, Kai Hormann, Ligang Liu, and Dmitry Anisimov (c) 2016-2017.

// README:
/*

    Local barycentric coordinates.

    This class depends on:
    1. BarycentricCoordinatesR2.hpp
    2. SegmentCoordinatesR2.hpp
    3. VertexExpressionsR2.hpp
    4. VertexR2.hpp
    5. TriangleCoordinatesR2.hpp

    This code also depends on the external triangulation library:
    Triangle, https://www.cs.cmu.edu/~quake/triangle.html
    I use the wrapper TriangulatorR2.hpp to include the library in the code.

    and it depends on the external linear algebra library: Eigen http://eigen.tuxfamily.org!

    The solver is provided by the authors: see extra/libs/lbcsolver.

*/

#ifndef GBC_LOCALR2_HPP
#define GBC_LOCALR2_HPP

// STL includes.
#include <vector>
#include <cassert>
#include <iostream>
#include <cmath>

// Local includes.
#include "../extra/VertexR2.hpp"
#include "../extra/BarycentricCoordinatesR2.hpp"
#include "../extra/TriangleCoordinatesR2.hpp"

// Libs.
#include "../extra/libs/eigen/Eigen/Core"
#include "../extra/libs/eigen/Eigen/Dense"

#include "../extra/TriangulatorR2.hpp"

#include "../extra/libs/lbcsolver/DataTypes.hpp"
#include "../extra/libs/lbcsolver/LbcSolver.hpp"

namespace gbc {

    // Local barycentric coordinates in R2.
    // May give slightly negative values, but this is numerical instability of the solver.
    class LocalR2 : public BarycentricCoordinatesR2 {

    public:
        // Constructor.
        LocalR2(const std::vector<VertexR2> &v, const double tol = 1.0e-10) 
        : super(v, tol), _edgeLength(-1.0), 
        _isPolyLoaded(false), 
        _isMeshGiven(false), 
        _isMeshCreated(false), 
        _areCoordinatesComputed(false), 
        _isEdgeLengthSet(false),
        _verbose(false) {

            setPolygon();
        }

        // Return name of the coordinate function.
        inline std::string name() const {
            return "LocalR2";
        }

        // Function that computes coordinates bb at all points p.
        // Here the set of points p must exclude the polygon's vertices _v.
        void compute(const std::vector<VertexR2> &p, std::vector<std::vector<double> > &bb) {

            // Create internal triangle mesh.
            createMesh(p);

            // Compute coordinates.
            lbc_solver();

            // Wrap computed coordinates in the vector bb.
            wrapCoordinates(bb);
        }

        // Compute coordinates bb at the vertices of the internal mesh with the given edgeLength
        // of the average triangle in this mesh. The number of returned coordinates is the number of the polygon's vertices 
        // + the number of the points p generated by the TriangulatorR2.hpp. All the coordinates are ordered as 
        // _v[0].b(), ..., _v[n-1].b(), p[0].b(), ..., p[N-1].b(), where n = _v.size() and N = p.size().
        void compute(const double edgeLength, std::vector<std::vector<double> > &bb) {

            // Create internal triangle mesh.
            createMesh(edgeLength);

            // Compute coordinates.
            lbc_solver();

            // Wrap computed coordinates in the vector bb.
            wrapCoordinates(bb);
        }

        // Compute coordinates at all points p in the vector using the internal storage from the VertexR2 class.
        // Note that here the function returns a slightly different set of points p from the given one.
        // Here the set of points p must exclude the polygon's vertices _v.
        void compute(std::vector<VertexR2> &p) {

            // Create internal triangle mesh.
            createMesh(p);

            // Compute coordinates.
            lbc_solver();

            // Wrap vertices with coordinates.
            wrapVertices(p);
        }

        // Implementation of the virtual function to compute all coordinates.
        // Here the set of points p must exclude the polygon's vertices _v 
        // apart from the case when the given mesh is used.
        inline void bc(std::vector<VertexR2> &p) {
            
            // Create internal triangle mesh.
            if (!_isMeshGiven) createMesh(p);

            // Compute coordinates.
            lbc_solver();

            // Wrap vertices with coordinates.
            wrapVertices(p);
        }

        // Evaluate coordinates b at any point p.
        void evaluate(const VertexR2 &p, std::vector<double> &b) const {

            assert(_isPolyLoaded);
            assert(_isMeshCreated);
            assert(_areCoordinatesComputed);

            std::vector<double> lambda;

            const size_t numF = _meshFaces.cols();
            for (size_t i = 0; i < numF; ++i) {

                const int i0 = _meshFaces(0, i);
                const int i1 = _meshFaces(1, i);
                const int i2 = _meshFaces(2, i);

                const VertexR2 v0 = VertexR2(_meshVertices(0, i0), _meshVertices(1, i0));
                const VertexR2 v1 = VertexR2(_meshVertices(0, i1), _meshVertices(1, i1));
                const VertexR2 v2 = VertexR2(_meshVertices(0, i2), _meshVertices(1, i2));

                TriangleCoordinatesR2 tc(v0, v1, v2);
                tc.compute(p, lambda);

                assert(lambda.size() == 3);

                if (lambda[0] >= 0.0 && 
                    lambda[1] >= 0.0 && 
                    lambda[2] >= 0.0) {

                    b.clear();

                    const size_t n = _v.size();
                    b.resize(n, 0.0);

                    assert(_meshVertices.cols() == _b.rows());
                    assert(_v.size()  ==  (size_t) _b.cols());

                    for (size_t j = 0; j < n; ++j)
                        b[j] = lambda[0] * _b(i0, j) + lambda[1] * _b(i1, j) + lambda[2] * _b(i2, j);

                    return;
                }
            }
            assert(false);
        }

        // Evalaute coordinates at p using the internal storage from the VertexR2 class.
        inline void evaluate(VertexR2 &p) const {
            evaluate(p, p.b());
        }

        // Evaluate coordinates bb at all points p in the vector.
        void evaluate(const std::vector<VertexR2> &p, std::vector<std::vector<double> > &bb) const {

            const size_t numP = p.size();
            
            bb.resize(numP);
            for (size_t i = 0; i < numP; ++i) evaluate(p[i], bb[i]);
        }

        // Evaluate coordinates at all points p in the vector using 
        // the internal storage from the VertexR2 class.
        void evaluate(std::vector<VertexR2> &p) const {

            const size_t numP = p.size();
            for (size_t i = 0; i < numP; ++i) evaluate(p[i], p[i].b());
        }

        // Set mesh if any.
        void setMesh(const std::vector<VertexR2> &tp, const std::vector<Face> &tf) {

            setTriangulation(tp, tf);

            _isMeshGiven = true;
            _isMeshCreated = false;
        }

        // Set the average edge length for the boundary refinement.
        inline void setEdgeLength(const double newEdgeLength) {

            assert(newEdgeLength > 0.0);
            
            _edgeLength = newEdgeLength;
            _isEdgeLengthSet = true;
        }

        // Indicate if we want to output the solver progress or not.
        // The default is false.
        inline void showOutput(const bool verbose) {
            _verbose = verbose;
        }

        // Clear all internal data structures.
        void clear() {

            _poly.resize(3, 0);
            _meshFaces.resize(0, 0);
            _meshVertices.resize(3, 0);
            _b.resize(0, 0);

            _isPolyLoaded = false;
            _isMeshGiven = false;
            _isMeshCreated = false;
            _areCoordinatesComputed = false;
            _isEdgeLengthSet = false;
        }

    private:
        // Some typedefs.
        typedef BarycentricCoordinatesR2 super;

        // Mesh.
        Eigen::MatrixXi  _meshFaces;
        Eigen::Matrix3Xd _meshVertices;

        // Polygon.
        Eigen::Matrix3Xd _poly;

        // Coordinates.
        Eigen::MatrixXd  _b;

        // Edge length of the average triangle in the internal triangulation.
        double _edgeLength;

        // Flags.
        bool _isPolyLoaded;
        bool _isMeshGiven;
        bool _isMeshCreated;
        bool _areCoordinatesComputed;
        bool _isEdgeLengthSet;
        bool _verbose;

        // Return the obtained coordinates.
        void wrapCoordinates(std::vector<std::vector<double> > &bb) const {

            const long rows = _b.rows();
            const long cols = _b.cols();

            bb.clear();
            bb.resize(rows);

            assert(_v.size() == (size_t) cols);
            for (long i = 0; i < rows; ++i) {

                bb[i].resize((size_t) cols);
                for (long j = 0; j < cols; ++j) bb[i][j] = _b(i, j);
            }
        }

        // Return new set of vertices with the corresponding coordinates
        // using the internal coordinate storage from the class VertexR2.
        void wrapVertices(std::vector<VertexR2> &p) const {

            const size_t n = _v.size();
            const size_t N = _meshVertices.cols();

            p.clear();
            p.resize(N);

            assert(N == (size_t) _b.rows());
            assert(_v.size() == (size_t) _b.cols());

            for (size_t i = 0; i < N; ++i) {

                p[i].x() = _meshVertices(0, i);
                p[i].y() = _meshVertices(1, i);

                p[i].b().resize(n, 0.0);
                for (size_t j = 0; j < n; ++j) p[i].b()[j] = _b(i, j);
            }
        }

        // Set vertices of the given polygon.
        void setPolygon() {

            const size_t numV = _v.size();
            _poly.resize(3, numV);

            for (size_t i = 0; i < numV; ++i) {

                _poly(0, i) = _v[i].x();
                _poly(1, i) = _v[i].y();
                _poly(2, i) = 0.0;
            }

            _isPolyLoaded = true;
        }

        // Given a set of points p, create the internal triangle mesh.
        // For this code the prefered edge length for the boundary
        // refinement is also necessary!
        void createMesh(const std::vector<VertexR2> &p) {

            assert(_isEdgeLengthSet);
            assert(_edgeLength > 0.0);

            std::vector<VertexR2> poly;
            refinePolygon(poly);

            assert(!p.empty());

            std::vector<VertexR2> tp;
            std::vector<Face> tf;

            TriangulatorR2 tri(poly);

            tri.setPlanarGraph(true);

            tri.allowBoundaryRefinement(false);
            tri.allowEdgeRefinement(false);

            tri.setPoints(p);
            tri.generate(tp, tf);

            setTriangulation(tp, tf);

            _isMeshGiven = false;
            _isMeshCreated = true;
        }

        // Given the edgeLength of the average triangle, create the internal triangle mesh.
        void createMesh(const double edgeLength) {

            _edgeLength = edgeLength;
            _isEdgeLengthSet = true;

            assert(_edgeLength > 0.0);

            std::vector<VertexR2> poly;
            refinePolygon(poly);

            std::vector<VertexR2> tp;
            std::vector<Face> tf;

            TriangulatorR2 tri(poly, _edgeLength, true);
            tri.setPlanarGraph(true);

            tri.generate(tp, tf);

            setTriangulation(tp, tf);

            _isMeshGiven = false;
            _isMeshCreated = true;
        }

        // Refine boundary of the given polygon _v with respect to the given _edgeLength.
        void refinePolygon(std::vector<VertexR2> &poly) const {

            assert(poly.empty());
            const size_t numV = _v.size();

            for (size_t i = 0; i < numV; ++i) {
                poly.push_back(_v[i]);

                const size_t ip = (i + 1) % numV;
                const size_t numS = ceil((_v[ip] - _v[i]).length() / _edgeLength);

                for (size_t j = 1; j < numS; ++j) {

                    VertexR2 vert = _v[i] + (double(j) / double(numS)) * (_v[ip] - _v[i]);
                    poly.push_back(vert);
                }
            }
        }

        // Set vertices and faces of the given triangulation.
        void setTriangulation(const std::vector<VertexR2> &tp, const std::vector<Face> &tf) {

            const size_t numP = tp.size();
            const size_t numF = tf.size();

            _meshVertices.resize(3, numP);

            for (size_t i = 0; i < numP; ++i) {

                _meshVertices(0, i) = tp[i].x();
                _meshVertices(1, i) = tp[i].y();
                _meshVertices(2, i) = 0.0;
            }

            _meshFaces.resize(3, numF);

            for (size_t i = 0; i < numF; ++i) {

                _meshFaces(0, i) = tf[i].v[0];
                _meshFaces(1, i) = tf[i].v[1];
                _meshFaces(2, i) = tf[i].v[2];
            }
        }

        // Compute coordinates. This implementation is based on the following paper:
        // J. Zhang, B. Deng, Z. Liu, G. Patane, S. Bouaziz, K. Hormann, and L. Liu. Local barycentric coordinates.
        // ACM Transactions on Graphics, 33(6):188:1-12, 2014.
        void lbc_solver(const int weighting_scheme = 2, // 0 - Constant, 1 - Linear, 2 - Quadratic, 3 - Sqrt
                        const int max_iter = 10000, // default is 10000
                        const double relaxation_alpha = 1.65, // default is 1.65
                        const double penalty_weight = 10.0, // default is 10.0
                        const double primal_residual_tolerance = 0.0000001, // default is 0.0000001
                        const double dual_residual_tolerance = 0.000001) { // default is 0.000001

            assert(_isPolyLoaded);
            assert(_isMeshCreated || _isMeshGiven);

            if (_verbose) std::cout << "Setting up input data..." << std::endl;

            LBC::DenseMatrix sample_points = _meshVertices.block(0, 0, 2, _meshVertices.cols());
            LBC::DenseIndexMatrix &cell_vertices = _meshFaces;

            // Control_point_idx.
            LBC::IndexVector control_point_idx(_poly.cols());
            for (int i = 0; i < _poly.cols(); ++i) {

                Eigen::Vector2d ctrl_pt = _poly.block(0, i, 2, 1);
                LBC::DenseMatrix candidate_points = sample_points;

                int min_idx = -1;
                (candidate_points.colwise() - ctrl_pt).colwise().norm().minCoeff(&min_idx);
                control_point_idx[i] = min_idx;
            }

            // Boundary_facet_info.
            std::vector<LBC::DataSetup::CageBoundaryFacetInfo> boundary_facet_info;
            int n_control_pt = (int) _poly.cols();
            for (int i = 0; i < n_control_pt; ++i) {

                int next_i = (i + 1) % n_control_pt;

                LBC::IndexVector facet_vertices(2);
                facet_vertices(0) = i;
                facet_vertices(1) = next_i;
                int n_segments = std::ceil((_poly.col(i) - _poly.col(next_i)).norm() / _edgeLength);

                LBC::IndexVector boundary_points(n_segments - 1);
                for (int k = 1; k < n_segments; ++k) {

                    Eigen::Vector3d pt_3d = _poly.col(i) + k * (_poly.col(next_i) - _poly.col(i)) / n_segments;
                    Eigen::Vector2d pt = pt_3d.head(2);

                    LBC::DenseMatrix candidate_points = sample_points;

                    int min_idx = -1;
                    (candidate_points.colwise() - pt).colwise().norm().minCoeff(&min_idx);
                    boundary_points[k - 1] = min_idx;
                }

                LBC::DataSetup::CageBoundaryFacetInfo edge(facet_vertices, boundary_points);
                boundary_facet_info.push_back(edge);
            }

            LBC::DataSetup::WeightingScheme scheme = static_cast<LBC::DataSetup::WeightingScheme>(weighting_scheme);
            LBC::DataSetup ds(sample_points, control_point_idx, cell_vertices, boundary_facet_info, scheme);

            LBC::Param param;

            param.max_iterations = max_iter;
            param.relaxation_alpha = relaxation_alpha;
            param.rel_primal_eps = primal_residual_tolerance;
            param.rel_dual_eps = dual_residual_tolerance;
            param.penalty_weight = penalty_weight;

            param.convergence_check_frequency = 10;

            if (_verbose) param.output_frequency_ratio = 10;
            else param.output_frequency_ratio = max_iter;

            param.use_timer = false;

            // Interior.
            LBC::LBCSolver solver(param, ds);
            solver.showOutput(_verbose);

            if (_verbose) std::cout << "LBC Solver started:\n" << std::endl;

            solver.solve();

            if (_verbose) std::cout << "Computation finished!\n" << std::endl;

            _b = ds.get_full_coordinate_values(solver.get_coordinates());
            _areCoordinatesComputed = true;
        }
    };

} // namespace gbc

#endif // GBC_LOCALR2_HPP
